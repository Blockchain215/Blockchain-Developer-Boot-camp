<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=">
  <link rel="stylesheet" href="../../../style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.0/gsap.min.js" async></script>
  <script src="../../../js/text-bounce.js" async></script>
  <title>Access Control Design Patterns</title>
</head>
<div class="body">
  
  <!-- Title goes below: -->
  <h1>Access Control Design Patterns</h1>
  
  <!-- Content here: -->

    <p>Access Control is a broad term. Most generally, it means who is allowed to do what on your smart contract. Who is allowed to mint new tokens, create a new pointer contract or release funds, for example.</p>

    <p>We'll be looking at Access Control from a Solidity and coding standpoint, but Access Control is actually a pivot point where the blockchain enters the real world. In the follwoiong examples, we'll write code to allow a certain <code>address</code> to do (or not do) a certain action. However, <code>address</code> may correspond to a user in the real world, granting them certain privileges over the contract. If that contract holds the funds for a group, that person is now the treasurer of the group!</p>

    <p>Something to keep in mind as we go through these different examples and a teaser for our later sections on DAOs.</p>

    <h2>Restricting Access and <code>Ownable</code></h2>

      <p>A very simple form of access control is making contract state private. You cannot prevent people or computer programs from reading your contracts’ state. The state is publicly available information for anyone with access to the blockchain. However, you <i>can</i> restrict other contracts’ access to the state by making state variables private, like in the basic example below:</p>
    
<pre>
  contract C1 {
  
          uint private internalNum;
  
  }
</pre>

      <p>This simple typing can provide some aspect of security through access control.</p>

      <p>A broader form of access control is the <code>Ownable</code> design pattern, the "Hello, World!" of access control, you might say. It designates a certain address, or addresses, as the "owner" or admin of the contract.</p>

      <p>As we learned earlier, function modifiers allow us to reuse code and increase contract readability. We can also use them to restrict access based on the Ownable model:</p>

      <pre>
  address owner;

  constructor() payable public {
      owner = msg.sender;
  }
  
  modifier onlyOwner() {
      require(msg.sender == owner, "Not authorized.");
      _;
  }
  
  function withdraw(uint _amount) onlyOwner public {
      owner.transfer(_amount);
  }
      </pre>

      <p>The above code declares the variable <code>owner</code> and assigns that role to whoever is creating the contract, using <code>msg.sender</code> global variable. We then declare a modifier <code>onlyOwner()</code>, which establishes a security check at the top of each function we assign it. Using the modifier syntax, we require a check of the identity of the transaction sender to see if it matches the declared <code>owner</code></p>

      <p>We then place this modifier in front of whichever functions we want to restrict access to. In this case, we're adding it to the <code>withdraw()</code> function (which makes sense, as we don't want anyone to be able to drain our contract of value!). This makes it so that the only user who can access this specific function is <code>owner</code>, all other addresses will fail.</p>

      <p>A common contract used for this is OpenZeppelin's <a href="https://docs.openzeppelin.com/contracts/2.x/api/ownership#Ownable" target="_blank" rel="noopener noreferrer">Ownable.sol</a>, which also lets you <code>transferOwnership</code> to another user or <code>renounceOwnership</code> if your contract only requires central authority for a certain period of time.</p>

      <p>Please note that the Ownable pattern is a bit fragile: It can become a single point of failure and is not very sophisticated in terms of Access Control.</p>

    <h2>Role-Based Access Control</h2>



    <h2>Pausable</h2>

      --discuss state machine here

      --emergency stop: https://docs.google.com/presentation/d/1ptNsTmevCp74tqyutr_3-FfVzM7scUKnuZZiBxiAdZU/edit#slide=id.g757369f1d7_1_132

      --state machine: https://docs.google.com/presentation/d/1ptNsTmevCp74tqyutr_3-FfVzM7scUKnuZZiBxiAdZU/edit#slide=id.g757369f1d7_1_148

    <h2>Additional Resources</h2>
      <ul>
        <li><a href="https://docs.openzeppelin.com/contracts/2.x/access-control" target="_blank" rel="noopener noreferrer">Wiki: Access Control</a> A comprehensive article from OpenZeppelin about Access Control design patterns and how contracts in their repository enacts different patterns.</li>
        <li><a href="https://docs.openzeppelin.com/contracts/2.x/api/ownership#Ownable" target="_blank" rel="noopener noreferrer">Code: OpenZeppelin's Ownable.sol</a></li>
        <li><a href="http://" target="_blank" rel="noopener noreferrer"></a></li>
        <li><a href="http://" target="_blank" rel="noopener noreferrer"></a></li>
      </ul>
  <!-- Be sure to alter the link below to add in correct Module and Lesson Number  -->
    <div class="footer">
      <a href="https://github.com/ConsenSys-Academy/Blockchain-Developer-Bootcamp/edit/main/S03-smart-contracts/M3-design-patterns/L3-inheritances-and-interfaces/index.html" target="_blank">Edit this page on Github</a>
      
      <div class="discord">
        <img class="discord-logo" src="../../../img/discord.svg" alt="Discord logo" ><a href="https://discord.gg/FrHSjSn9dX" target="_blank" >Questions? Ask on Discord! </a>  
      </div> 
    </div>
</div>

</html>